"""
xpathmodule.py

This script creates the files xpathmodule.c and xpathmodule.h
"""
import time, re

import_table = [
    "root",
    "step",
    "axis",
    "nameTest",
    "nodeType",
    "predicate",
    "pathExpr",
    "filterExpr",
    "function",
    "variableRef",
    "argument",
    "binaryOperator",
    "negative",
    "Number",
    "Literal",
    "XPathExpression",
]

def header(f) :
    f.write("""/************************************************************
This file was automaticaly generated by the xpathmodule.py
script on """)
    f.write(time.ctime(time.time()))
    f.write(""" do not edit this file
*************************************************************/""")

    f.write("\n\n")

#create xpathmodule.h

h = file("xpathmodule.h", "w")

header(h)

h.write("struct ImportTable {\n")
for i in import_table :
    h.write("  PyObject *%s"  %i)
    h.write(";\n")
h.write("};\n\n")
h.write("typedef struct ImportTable ImportTable;\n\n")
h.write("int yylex(YYSTYPE *, PyObject *);\n")
h.write("void yyerror (ImportTable*, PyObject*, PyObject**, char const*);\n\n")

h.close()

#create xpathmodule.c

c = file("xpathmodule.c", "w")

header(c)

y = file("xpath.y", "r")
pattern = re.compile("%token (.*)")
token_table = []
while True :
    line = y.readline()
    if not line :
        break
    m = pattern.match(line)
    if m :
        token_table.append(m.group(1).strip())
y.close()

c.write("""#include "Python/Python.h"
#include "xpath.h"
#include "xpathmodule.h"
#include <stdio.h>


int yylex(YYSTYPE *lvalp, PyObject *lex_object)
{
  PyObject *arglist, *r_val;
  int token;
  /*printf("at start of yylex\\n");
  printf("%p\\n", lex_object);*/
  arglist = Py_BuildValue("()");
  r_val = PyEval_CallObject(lex_object, arglist);
  if (! r_val)
    return 0;
  PyArg_ParseTuple(r_val, "iO", &token, lvalp);
  /* should check return value */
  Py_INCREF((PyObject*)(*lvalp));
  Py_DECREF(r_val);
  Py_DECREF(arglist);
  /*printf("at end of yylex\\n");*/
  return token; 
}

void yyerror (ImportTable *functions, PyObject* lex_object, PyObject **result, char const* c) {

}

/* does this need to be static?*/ /*It does not look like it!*/
PyObject* parse(PyObject *self, PyObject *args)
{
  ImportTable functions;
  PyObject *parser_backend, *lex_object, *result, *none;
  int r_val;
  /*none = Py_None ;
  printf("None = %p\\n", none);*/
  if  (! PyArg_ParseTuple(args, "OO", &parser_backend, &lex_object))
    return 0;
  /*printf("%p\\n", lex_object);
  printf("parser_backend = %p\\n", parser_backend);*/
""")
for method in import_table :
    c.write("  functions.%s = PyMapping_GetItemString(parser_backend, \"%s\");\n" %
            (method,method))
    c.write("  if (! functions.%s) \n" % method)
    c.write("    return 0;\n")
c.write("""
  result = NULL;
  r_val = yyparse(&functions, lex_object, &result);

""")
for method in import_table :
    c.write("  Py_DECREF(functions.%s);\n" % method)
c.write("""
  if (r_val == 0)
    return result;
  return 0;
}

static PyMethodDef xpathc_methods[] = {
    {"parse",  parse, METH_VARARGS, "Parse an XPath expression."},
    {NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC initxpathc()
{
  PyObject *t, *m;
  m = Py_InitModule("xpathc", xpathc_methods);
""")
for token in token_table :
  #c.write("  /* %s */\n" % token)
  c.write("  t = PyInt_FromLong(%s);\n" % token)
  c.write("  PyModule_AddObject(m, \"%s\", t);\n" % token)
  #c.write("  Py_DECREF(t);\n")
c.write("""
}

""")

c.close()

